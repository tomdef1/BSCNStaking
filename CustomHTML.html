<script>

// Load Web3
window.addEventListener("load", async () => {
  if (window.ethereum) {
    window.web3 = new Web3(ethereum);
    try {
      await ethereum.request({
        method: "eth_requestAccounts",
      });
    } catch (e) {
      console.error("User denied account access");
    }
  } else
    window.web3
      ? (window.web3 = new Web3(web3.currentProvider))
      : alert("Non-Ethereum browser detected. Consider installing MetaMask");

  accounts = await web3.eth.getAccounts();
  updateData(accounts[0]);
});

let accounts;
// Staking contract details for "Ignore Fud" pool
const stakingContractAddressIgnoreFud = "0xe1ffa6019F8C9aD629E1bC9997723565D0Dd2E0D";
// Staking contract details for "Chain GPT" pool
const stakingContractAddressChainGPT = "0x136080F5f31f620B3cf331bc83c059043bAe3331";
const stakingAbi = [
  {
    inputs: [
      { internalType: "address", name: "_nftCollection", type: "address" },
      { internalType: "address", name: "_rewardToken", type: "address" },
    ],
    stateMutability: "nonpayable",
    type: "constructor",
  },
  {
    inputs: [{ internalType: "uint256[]", name: "tokenIds", type: "uint256[]" }],
    name: "stake",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [],
    name: "totalStakedSupply",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      { internalType: "uint256[]", name: "tokenIds", type: "uint256[]" },
    ],
    name: "withdraw",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [{ internalType: "address", name: "_user", type: "address" }],
    name: "userStakedTokens",
    outputs: [
      { internalType: "uint256[]", name: "_tokensStaked", type: "uint256[]" },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "claimRewards",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [{ internalType: "address", name: "_user", type: "address" }],
    name: "userStakeRewards",
    outputs: [{ internalType: "uint256", name: "_rewardAmount", type: "uint256" }],
    stateMutability: "view",
    type: "function",
	},
];

//NFT contract details
const nftContractAddress = "0xD15360dEF9f520c4b6449299d24C5Be08751307E";
const nftAbi = [
  {
    inputs: [
      { internalType: "address", name: "operator", type: "address" },
      { internalType: "bool", name: "approved", type: "bool" },
    ],
    name: "setApprovalForAll",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
];

// Binance Smart Chain Mainnet Configuration x BSC News & BloXroute
const networkId = "0x38"; // Binance Smart Chain Mainnet ID in hexadecimal
const chainId = "0x38"; // Binance Smart Chain Mainnet Chain ID in hexadecimal
const rpcUrl = "https://bsc.rpc.blxrbdn.com/"; // Binance Smart Chain Mainnet RPC URL
//ORIGINAL/DEFAULT: const rpcUrl = "https://bsc.rpc.blxrbdn.com/"; // Binance Smart Chain Mainnet RPC URL
	
async function updateData(account) {
  try {		
    // Contract declarations
    const stakingContract = new web3.eth.Contract(
      stakingAbi,
      stakingContractAddress
    );

    let totalStakes = await stakingContract.methods.totalStakedSupply().call();
    totalStakesElement.textContent = totalStakes;

    let userStakesCount = (
      await stakingContract.methods.userStakedTokens(account).call()
    ).length;
    userStakesElement.textContent = userStakesCount;

    let userStakedTokens = await stakingContract.methods
      .userStakedTokens(account)
      .call();
    userStakedTokensElement.textContent = userStakedTokens;
  } catch (error) {
    alert(
      `Failed to dynamically update relevant variables! Error: ${error.message}`
    );
  }
}

async function checkAndSwitchChain() {
  const currentChainIdHex = await web3.eth.getChainId();
  if (currentChainIdHex !== chainId) {
    try {
      await ethereum.request({
        method: "wallet_switchEthereumChain",
        params: [{ chainId: chainId }],
      });
    } catch (switchError) {
      console.error(switchError);
    }
  }
}

/*
 _____                             ______         _ 
 |_   _|                           |  ____|       | |
   | |  __ _ _ __   ___  _ __ ___  | |__ _   _  __| |
   | | / _` | '_ \ / _ \| '__/ _ \ |  __| | | |/ _` |
  _| || (_| | | | | (_) | | |  __/ | |  | |_| | (_| |
 |_____\__, |_| |_|\___/|_|  \___| |_|   \__,_|\__,_|
        __/ |                                        
       |___/                                         
Functions for "Ignore Fud" pool
*/
async function stakeTokenIgnoreFud() {
  try {
    // Check and change to BSC Testnet if required
    checkAndSwitchChain();

    // Contract declarations
  const stakingContract = new web3.eth.Contract(
	  stakingAbi,
	  stakingContractAddressIgnoreFud
  );
	const myNftContract = new web3.eth.Contract(
	    nftAbi, 
	    nftContractAddress
	);
	  
    let tokenInputField = document.querySelector(".token-id-input");
    let tokenIds = tokenInputField.value.split(",").map(Number);
    tokenInputField.value = ""; // clear the input field after reading the value

    // Approve all NFTs for staking
    await myNftContract.methods
      .setApprovalForAll(stakingContractAddress, true)
      .send({ from: accounts[0] })
      .on("receipt", function (receipt) {
        console.log(`NFTs approved for staking!`);
      })
      .on("error", function (error, receipt) {
        console.log(`Error approving NFTs for staking`);
      });

    stakingContract.methods
      .stake(tokenIds)
      .send({ from: accounts[0] })
      .on("receipt", function (receipt) {
        console.log(receipt);
        alert("Success!");
      })
      .on("error", function (error, receipt) {
        console.log(error);
      });
  } catch (error) {
    alert(
      `An error occurred while staking your tokens. Please try again. Error details: ${error.message}`
    );
  }
  updateData(accounts[0]);
}

async function unstakeTokenIgnoreFud() {
  try {
    // Check and change to BSC Testnet if required
    checkAndSwitchChain();

    // Contract declarations
    const stakingContract = new web3.eth.Contract(
	    stakingAbi,
	    stakingContractAddressIgnoreFud
    );

    let tokenInputField = document.querySelector(".token-id-input");
    let tokenIds = tokenInputField.value.split(",").map(Number);
    tokenInputField.value = ""; // clear the input field after reading the value

    stakingContract.methods
      .withdraw(tokenIds)
      .send({ from: accounts[0] })
      .on("receipt", function (receipt) {
        console.log(receipt);
        alert("Success!");
      })
      .on("error", function (error, receipt) {
        console.log(error);
      });
  } catch (error) {
    alert(
      `An error occurred while unstaking your tokens. Please try again. Error: ${error.message}`
    );
  }
  updateData(accounts[0]);
}

async function claimRewardsIgnoreFud() {
  try {
    // Check and change to BSC Testnet if required
    checkAndSwitchChain();

    // Contract declarations
  const stakingContract = new web3.eth.Contract(
	  stakingAbi, 
	  stakingContractAddressIgnoreFud
  );

    stakingContract.methods
      .claimRewards()
      .send({ from: accounts[0] })
      .on("receipt", function (receipt) {
        console.log(receipt);
        alert("Success!");
      })
      .on("error", function (error, receipt) {
        console.log(error);
      });
  } catch (error) {
    alert(
      `An error occurred while claiming your rewards. Please try again. Error: ${error.message}`
    );
  }
  updateData(accounts[0]);
}

async function checkRewardsIgnoreFud() {
  try {
    // Check and change to BSC Testnet if required
    checkAndSwitchChain();

    // Contract declarations
const stakingContract = new web3.eth.Contract(
	stakingAbi,
	stakingContractAddressIgnoreFud
);

    let reward = await stakingContract.methods
      .userStakeRewards(accounts[0])
      .call();
    reward = web3.utils.fromWei(reward, "ether");

    // Convert the reward to a floating point number
    let rewardFloat = parseFloat(reward);

    // Use Math.floor() to round down
    let flooredReward = Math.floor(rewardFloat);

    // Convert the number to a string with commas
    let formattedReward = flooredReward.toLocaleString();

    alert(`You have earned a total of: ${formattedReward} $4TOKEN!`);
  } catch (error) {
    alert(
      `An error occurred while checking your rewards. Please try again. Error: ${error.message}`
    );
  }
}

/*
   _____ _           _        _____ _____ _______ 
  / ____| |         (_)      / ____|  __ \__   __|
 | |    | |__   __ _ _ _ __ | |  __| |__) | | |   
 | |    | '_ \ / _` | | '_ \| | |_ |  ___/  | |   
 | |____| | | | (_| | | | | | |__| | |      | |   
  \_____|_| |_|\__,_|_|_| |_|\_____|_|      |_|   
                                                  
Functions for "Ignore Fud" pool
*/
async function stakeTokenChainGPT() {
  try {
    // Check and change to BSC Testnet if required
    checkAndSwitchChain();

    // Contract declarations
    const stakingContract = new web3.eth.Contract(stakingAbi, stakingContractAddressChainGPT);

	const myNftContract = new web3.eth.Contract(
	    nftAbi, 
	    nftContractAddress
	);
	  
    let tokenInputField = document.querySelector(".token-id-input");
    let tokenIds = tokenInputField.value.split(",").map(Number);
    tokenInputField.value = ""; // clear the input field after reading the value

    // Approve all NFTs for staking
    await myNftContract.methods
      .setApprovalForAll(stakingContractAddress, true)
      .send({ from: accounts[0] })
      .on("receipt", function (receipt) {
        console.log(`NFTs approved for staking!`);
      })
      .on("error", function (error, receipt) {
        console.log(`Error approving NFTs for staking`);
      });

    stakingContract.methods
      .stake(tokenIds)
      .send({ from: accounts[0] })
      .on("receipt", function (receipt) {
        console.log(receipt);
        alert("Success!");
      })
      .on("error", function (error, receipt) {
        console.log(error);
      });
  } catch (error) {
    alert(
      `An error occurred while staking your tokens. Please try again. Error details: ${error.message}`
    );
  }
  updateData(accounts[0]);
}

async function unstakeTokenChainGPT() {
  try {
    // Check and change to BSC Testnet if required
    checkAndSwitchChain();

    // Contract declarations
	const stakingContract = new web3.eth.Contract(stakingAbi, stakingContractAddressChainGPT);

    let tokenInputField = document.querySelector(".token-id-input");
    let tokenIds = tokenInputField.value.split(",").map(Number);
    tokenInputField.value = ""; // clear the input field after reading the value

    stakingContract.methods
      .withdraw(tokenIds)
      .send({ from: accounts[0] })
      .on("receipt", function (receipt) {
        console.log(receipt);
        alert("Success!");
      })
      .on("error", function (error, receipt) {
        console.log(error);
      });
  } catch (error) {
    alert(
      `An error occurred while unstaking your tokens. Please try again. Error: ${error.message}`
    );
  }
  updateData(accounts[0]);
}

async function claimRewardsChainGPT() {
  try {
    // Check and change to BSC Testnet if required
    checkAndSwitchChain();

    // Contract declarations
    const stakingContract = new web3.eth.Contract(stakingAbi, stakingContractAddressChainGPT);

    stakingContract.methods
      .claimRewards()
      .send({ from: accounts[0] })
      .on("receipt", function (receipt) {
        console.log(receipt);
        alert("Success!");
      })
      .on("error", function (error, receipt) {
        console.log(error);
      });
  } catch (error) {
    alert(
      `An error occurred while claiming your rewards. Please try again. Error: ${error.message}`
    );
  }
  updateData(accounts[0]);
}

async function checkRewardsIgnoreFud() {
  try {
    // Check and change to BSC Testnet if required
    checkAndSwitchChain();

    // Contract declarations
const stakingContract = new web3.eth.Contract(
	stakingAbi,
	stakingContractAddressIgnoreFud
);

    let reward = await stakingContract.methods
      .userStakeRewards(accounts[0])
      .call();
    reward = web3.utils.fromWei(reward, "ether");

    // Convert the reward to a floating point number
    let rewardFloat = parseFloat(reward);

    // Use Math.floor() to round down
    let flooredReward = Math.floor(rewardFloat);

    // Convert the number to a string with commas
    let formattedReward = flooredReward.toLocaleString();

    alert(`You have earned a total of: ${formattedReward} $4TOKEN!`);
  } catch (error) {
    alert(
      `An error occurred while checking your rewards. Please try again. Error: ${error.message}`
    );
  }
}

// Attach event to image for "IgnoreFud" pool
const stakeButton = document.querySelector(".stake");
stakeButton.addEventListener("click", stakeToken);

const unstakeButton = document.querySelector(".unstake");
unstakeButton.addEventListener("click", unstakeToken);

const claimButton = document.querySelector(".claim");
claimButton.addEventListener("click", claimRewards);

const checkButton = document.querySelector(".check");
checkButton.addEventListener("click", checkRewards);

let totalStakesElement = document.querySelector("#total-staked");
let userStakesElement = document.querySelector("#user-staked");
let userStakedTokensElement = document.querySelector("#staked-tokens");

// Attach event to image for "Chain GPT" pool
const stakeButtonChainGPT = document.querySelector(".stake-chain-gpt");
stakeButtonChainGPT.addEventListener("click", stakeTokenChainGPT);

const unstakeButtonChainGPT = document.querySelector(".unstake-chain-gpt");
unstakeButtonChainGPT.addEventListener("click", unstakeTokenChainGPT);

const claimButtonChainGPT = document.querySelector(".claim-chain-gpt");
claimButtonChainGPT.addEventListener("click", claimRewardsChainGPT);

const checkButtonChainGPT = document.querySelector(".check-chain-gpt");
checkButtonChainGPT.addEventListener("click", checkRewardsChainGPT);

let totalStakesElement = document.querySelector("#total-staked");
let userStakesElement = document.querySelector("#user-staked");
let userStakedTokensElement = document.querySelector("#staked-tokens");

</script>
