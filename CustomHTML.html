<script>
let accounts;

// Load Web3
window.addEventListener("load", async () => {
    if (window.ethereum) {
        window.web3 = new Web3(ethereum);
        try {
            accounts = await web3.eth.getAccounts();

            if (!accounts || accounts.length === 0) {
                // Request user to connect their MetaMask account
                accounts = await ethereum.request({ method: 'eth_requestAccounts' });
                
                if (!accounts || accounts.length === 0) {
                    throw new Error("No accounts found. Please ensure you're connected to the network.");
                }
            }

            updateData(accounts[0]);
        } catch (e) {
            console.error("Error fetching accounts:", e.message);
            alert("Error fetching accounts. Please ensure you're connected and try again.");
        }
    } else {
        alert("Non-Ethereum browser detected. Consider installing MetaMask");
        window.web3 = new Web3(new Web3.providers.HttpProvider(rpcUrl));
    }
});

    // Staking contract details for "Ignore Fud" pool
    const stakingContractAddressIgnoreFud = "0xe1ffa6019F8C9aD629E1bC9997723565D0Dd2E0D";
    // Staking contract details for "Chain GPT" pool
    const stakingContractAddressChainGPT = "0x136080F5f31f620B3cf331bc83c059043bAe3331";
    let stakingContractAddress = stakingContractAddressIgnoreFud; // Default

    const stakingAbi = [
        {
            inputs: [
                { internalType: "address", name: "_nftCollection", type: "address" },
                { internalType: "address", name: "_rewardToken", type: "address" },
            ],
            stateMutability: "nonpayable",
            type: "constructor",
        },
        {
            inputs: [{ internalType: "uint256[]", name: "tokenIds", type: "uint256[]" }],
            name: "stake",
            outputs: [],
            stateMutability: "nonpayable",
            type: "function",
        },
        {
            inputs: [],
            name: "totalStakedSupply",
            outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
            stateMutability: "view",
            type: "function",
        },
        {
            inputs: [
                { internalType: "uint256[]", name: "tokenIds", type: "uint256[]" },
            ],
            name: "withdraw",
            outputs: [],
            stateMutability: "nonpayable",
            type: "function",
        },
        {
            inputs: [{ internalType: "address", name: "_user", type: "address" }],
            name: "userStakedTokens",
            outputs: [
                { internalType: "uint256[]", name: "_tokensStaked", type: "uint256[]" },
            ],
            stateMutability: "view",
            type: "function",
        },
        {
            inputs: [],
            name: "claimRewards",
            outputs: [],
            stateMutability: "nonpayable",
            type: "function",
        },
        {
            inputs: [{ internalType: "address", name: "_user", type: "address" }],
            name: "userStakeRewards",
            outputs: [{ internalType: "uint256", name: "_rewardAmount", type: "uint256" }],
            stateMutability: "view",
            type: "function",
        },
    ];

    //NFT contract details
    const nftContractAddress = "0xD15360dEF9f520c4b6449299d24C5Be08751307E";
    const nftAbi = [
        {
            inputs: [
                { internalType: "address", name: "operator", type: "address" },
                { internalType: "bool", name: "approved", type: "bool" },
            ],
            name: "setApprovalForAll",
            outputs: [],
            stateMutability: "nonpayable",
            type: "function",
        },
    ];

    // BSC Mainnet Configuration
    const networkId = "0x38";
    const chainId = "0x38";
    const rpcUrl = "https://bsc.rpc.blxrbdn.com/";

    function setStakingContract(contractChoice) {
        if (contractChoice === "ChainGPT") {
            stakingContractAddress = stakingContractAddressChainGPT;
        } else if (contractChoice === "4token") {
            stakingContractAddress = stakingContractAddressIgnoreFud;
        }
    }

    async function updateData(account) {
        try {
            // Contract declarations
            const stakingContract = new web3.eth.Contract(
                stakingAbi,
                stakingContractAddress
            );

            let totalStakes = await stakingContract.methods.totalStakedSupply().call();
            totalStakesElement.textContent = totalStakes;

            let userStakesCount = (
                await stakingContract.methods.userStakedTokens(account).call()
            ).length;
            userStakesElement.textContent = userStakesCount;

            let userStakedTokens = await stakingContract.methods
                .userStakedTokens(account)
                .call();
            userStakedTokensElement.textContent = userStakedTokens;
        } catch (error) {
            alert(
                `Failed to dynamically update relevant variables! Error: ${error.message}`
            );
        }
    }

    async function checkAndSwitchChain() {
        const currentChainIdHex = await web3.eth.getChainId();
        if (currentChainIdHex !== chainId) {
            try {
                await ethereum.request({
                    method: "wallet_switchEthereumChain",
                    params: [{ chainId: chainId }],
                });
            } catch (switchError) {
                console.error(switchError);
            }
        }
    }

    //Functions

    async function stakeToken(pool) {
        const stakingContract = new web3.eth.Contract(stakingAbi, stakingContractAddress);
        let tokenIds;

        if (pool === "4token") {
            // Fetch token IDs from the 'Token Id Input Fud' input field
            tokenIds = document.querySelector('#TokenIdInputFud').value.split(',').map(id => {
                const parsedId = parseInt(id.trim());
                if (isNaN(parsedId)) {
                    throw new Error("Invalid Token ID provided");
                }
                return parsedId;
            });

            // Logic for staking in "Ignore Fud" pool
            try {
                const receipt = await stakingContract.methods.stake(tokenIds).send({ from: accounts[0] });
                console.log('Staked successfully in Ignore Fud pool:', receipt);
            } catch (error) {
                console.error('Error staking in Ignore Fud pool:', error);
            }
        } else if (pool === "ChainGPT") {
            // Fetch token IDs from the 'Token ID Input Chain' input field
            tokenIds = document.querySelector('#TokenIdInputChain').value.split(',').map(id => {
                const parsedId = parseInt(id.trim());
                if (isNaN(parsedId)) {
                    throw new Error("Invalid Token ID provided");
                }
                return parsedId;
            });

            // Logic for staking in "ChainGPT" pool
            try {
                const receipt = await stakingContract.methods.stake(tokenIds).send({ from: accounts[0] });
                console.log('Staked successfully in ChainGPT pool:', receipt);
            } catch (error) {
                console.error('Error staking in ChainGPT pool:', error);
            }
        }
    }

    async function unstakeToken(pool) {
        const stakingContract = new web3.eth.Contract(stakingAbi, stakingContractAddress);
        let tokenIds;

        if (pool === "4token") {
            // Fetch token IDs from the 'Token Id Input Fud' input field
            tokenIds = document.querySelector('#TokenIdInputFud').value.split(',').map(id => parseInt(id.trim()));

            // Logic for unstaking in "Ignore Fud" pool
            try {
                const receipt = await stakingContract.methods.withdraw(tokenIds).send({ from: accounts[0] });
                console.log('Unstaked successfully from Ignore Fud pool:', receipt);
            } catch (error) {
                console.error('Error unstaking from Ignore Fud pool:', error);
            }
        } else if (pool === "ChainGPT") {
            // Fetch token IDs from the 'Token ID Input Chain' input field
            tokenIds = document.querySelector('#TokenIdInputChain').value.split(',').map(id => parseInt(id.trim()));

            // Logic for unstaking in "ChainGPT" pool
            try {
                const receipt = await stakingContract.methods.withdraw(tokenIds).send({ from: accounts[0] });
                console.log('Unstaked successfully from ChainGPT pool:', receipt);
            } catch (error) {
                console.error('Error unstaking from ChainGPT pool:', error);
            }
        }
    }


    async function claimRewards(pool) {
        const stakingContract = new web3.eth.Contract(stakingAbi, stakingContractAddress);
        if (pool === "4token") {
            // Logic for claiming rewards in "Ignore Fud" pool
            try {
                const receipt = await stakingContract.methods.claimRewards().send({ from: accounts[0] });
                console.log('Rewards claimed successfully from Ignore Fud pool:', receipt);
            } catch (error) {
                console.error('Error claiming rewards from Ignore Fud pool:', error);
            }
        } else if (pool === "ChainGPT") {
            // Logic for claiming rewards in "ChainGPT" pool
            try {
                const receipt = await stakingContract.methods.claimRewards().send({ from: accounts[0] });
                console.log('Rewards claimed successfully from ChainGPT pool:', receipt);
            } catch (error) {
                console.error('Error claiming rewards from ChainGPT pool:', error);
            }
        }
    }

    async function checkRewards(pool) {
        const stakingContract = new web3.eth.Contract(stakingAbi, stakingContractAddress);
        if (pool === "4token") {
            // Logic for checking rewards in "Ignore Fud" pool
            try {
                const rewards = await stakingContract.methods.userStakeRewards(accounts[0]).call();
                console.log('Rewards for Ignore Fud pool:', rewards);
            } catch (error) {
                console.error('Error checking rewards for Ignore Fud pool:', error);
            }
        } else if (pool === "ChainGPT") {
            // Logic for checking rewards in "ChainGPT" pool
            try {
                const rewards = await stakingContract.methods.userStakeRewards(accounts[0]).call();
                console.log('Rewards for ChainGPT pool:', rewards);
            } catch (error) {
                console.error('Error checking rewards for ChainGPT pool:', error);
            }
        }
    }
    // enhanced (buttons) event listeners
    document.querySelector(".stake-fud").addEventListener("click", async function () {
        try {
            await checkAndSwitchChain();
            await stakeToken("4token");
        } catch (error) {
            console.error("Error staking FUD token:", error);
            alert("Error staking FUD token. Please try again.");
        }
    });
    document.querySelector(".unstake-fud").addEventListener("click", async function () {
        try {
            await checkAndSwitchChain();
            await unstakeToken("4token");
        } catch (error) {
            console.error("Error unstaking FUD token:", error);
            alert("Error unstaking FUD token. Please try again.");
        }
    });
    document.querySelector(".claim-fud").addEventListener("click", async function () {
        try {
            await checkAndSwitchChain();
            await claimRewards("4token");
        } catch (error) {
            console.error("Error claiming rewards for FUD token:", error);
            alert("Error claiming rewards for FUD token. Please try again.");
        }
    });
    document.querySelector(".check-fud").addEventListener("click", async function () {
        try {
            await checkAndSwitchChain();
            await checkRewards("4token");
        } catch (error) {
            console.error("Error checking rewards for FUD token:", error);
            alert("Error checking rewards for FUD token. Please try again.");
        }
    });
    document.querySelector(".stake-chain-gpt").addEventListener("click", async function () {
        try {
            await checkAndSwitchChain();
            await stakeToken("ChainGPT");
        } catch (error) {
            console.error("Error staking ChainGPT token:", error);
            alert("Error staking ChainGPT token. Please try again.");
        }
    });
    document.querySelector(".unstake-chain-gpt").addEventListener("click", async function () {
        try {
            await checkAndSwitchChain();
            await unstakeToken("ChainGPT");
        } catch (error) {
            console.error("Error unstaking ChainGPT token:", error);
            alert("Error unstaking ChainGPT token. Please try again.");
        }
    });
    document.querySelector(".claim-chain-gpt").addEventListener("click", async function () {
        try {
            await checkAndSwitchChain();
            await claimRewards("ChainGPT");
        } catch (error) {
            console.error("Error claiming rewards for ChainGPT token:", error);
            alert("Error claiming rewards for ChainGPT token. Please try again.");
        }
    });
    document.querySelector(".check-chain-gpt").addEventListener("click", async function () {
        try {
            await checkAndSwitchChain();
            await checkRewards("ChainGPT");
        } catch (error) {
            console.error("Error checking rewards for ChainGPT token:", error);
            alert("Error checking rewards for ChainGPT token. Please try again.");
        }
    });
</script>
