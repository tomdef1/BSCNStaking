<script>
    // Load Web3
    window.addEventListener("load", async () => {
        if (window.ethereum) {
            window.web3 = new Web3(ethereum);
            try {
                await ethereum.request({
                    method: "eth_requestAccounts",
                });
            } catch (e) {
                console.error("User denied account access");
            }
        } else if (window.web3) {
            window.web3 = new Web3(web3.currentProvider);
        } else {
            alert("Non-Ethereum browser detected. Consider installing MetaMask");
        }

        accounts = await web3.eth.getAccounts();
        updateData(accounts[0]);
    });

    let accounts;
    // Staking contract details for "Ignore Fud" pool
    const stakingContractAddressIgnoreFud = "0xe1ffa6019F8C9aD629E1bC9997723565D0Dd2E0D";
    // Staking contract details for "Chain GPT" pool
    const stakingContractAddressChainGPT = "0x136080F5f31f620B3cf331bc83c059043bAe3331";
    let stakingContractAddress = stakingContractAddressIgnoreFud; // Default
    const stakingAbi = [
        {
            inputs: [
                { internalType: "address", name: "_nftCollection", type: "address" },
                { internalType: "address", name: "_rewardToken", type: "address" },
            ],
            stateMutability: "nonpayable",
            type: "constructor",
        },
        {
            inputs: [{ internalType: "uint256[]", name: "tokenIds", type: "uint256[]" }],
            name: "stake",
            outputs: [],
            stateMutability: "nonpayable",
            type: "function",
        },
        {
            inputs: [],
            name: "totalStakedSupply",
            outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
            stateMutability: "view",
            type: "function",
        },
        {
            inputs: [
                { internalType: "uint256[]", name: "tokenIds", type: "uint256[]" },
            ],
            name: "withdraw",
            outputs: [],
            stateMutability: "nonpayable",
            type: "function",
        },
        {
            inputs: [{ internalType: "address", name: "_user", type: "address" }],
            name: "userStakedTokens",
            outputs: [
                { internalType: "uint256[]", name: "_tokensStaked", type: "uint256[]" },
            ],
            stateMutability: "view",
            type: "function",
        },
        {
            inputs: [],
            name: "claimRewards",
            outputs: [],
            stateMutability: "nonpayable",
            type: "function",
        },
        {
            inputs: [{ internalType: "address", name: "_user", type: "address" }],
            name: "userStakeRewards",
            outputs: [{ internalType: "uint256", name: "_rewardAmount", type: "uint256" }],
            stateMutability: "view",
            type: "function",
        },
    ];

    //NFT contract details
    const nftContractAddress = "0xD15360dEF9f520c4b6449299d24C5Be08751307E";
    const nftAbi = [
        {
            inputs: [
                { internalType: "address", name: "operator", type: "address" },
                { internalType: "bool", name: "approved", type: "bool" },
            ],
            name: "setApprovalForAll",
            outputs: [],
            stateMutability: "nonpayable",
            type: "function",
        },
    ];

    // BSC Mainnet Configuration
    const networkId = "0x38";
    const chainId = "0x38";
    const rpcUrl = "https://bsc.rpc.blxrbdn.com/";

    function setStakingContract(contractChoice) {
        if (contractChoice === "ChainGPT") {
            stakingContractAddress = stakingContractAddressChainGPT;
        } else if (contractChoice === "4token") {
            stakingContractAddress = stakingContractAddressIgnoreFud;
        }
    }

    async function updateData(account) {
        try {
            // Contract declarations
            const stakingContract = new web3.eth.Contract(
                stakingAbi,
                stakingContractAddress
            );

            let totalStakes = await stakingContract.methods.totalStakedSupply().call();
            totalStakesElement.textContent = totalStakes;

            let userStakesCount = (
                await stakingContract.methods.userStakedTokens(account).call()
            ).length;
            userStakesElement.textContent = userStakesCount;

            let userStakedTokens = await stakingContract.methods
                .userStakedTokens(account)
                .call();
            userStakedTokensElement.textContent = userStakedTokens;
        } catch (error) {
            alert(
                `Failed to dynamically update relevant variables! Error: ${error.message}`
            );
        }
    }

    async function checkAndSwitchChain() {
        const currentChainIdHex = await web3.eth.getChainId();
        if (currentChainIdHex !== chainId) {
            try {
                await ethereum.request({
                    method: "wallet_switchEthereumChain",
                    params: [{ chainId: chainId }],
                });
            } catch (switchError) {
                console.error(switchError);
            }
        }
    }

 //Functions

    async function stakeToken(pool) {
        const stakingContract = new web3.eth.Contract(stakingAbi, stakingContractAddress);
        let tokenIds;

        if (pool === "4token") {
            // Fetch token IDs from the 'Token Id Input Fud' input field
            tokenIds = document.querySelector('#TokenIdInputFud').value.split(',').map(id => parseInt(id.trim()));

            // Logic for staking in "Ignore Fud" pool
            try {
                const receipt = await stakingContract.methods.stake(tokenIds).send({ from: accounts[0] });
                console.log('Staked successfully in Ignore Fud pool:', receipt);
            } catch (error) {
                console.error('Error staking in Ignore Fud pool:', error);
            }
        } else if (pool === "ChainGPT") {
            // Fetch token IDs from the 'Token ID Input Chain' input field
            tokenIds = document.querySelector('#TokenIdInputChain').value.split(',').map(id => parseInt(id.trim()));

            // Logic for staking in "ChainGPT" pool
            try {
                const receipt = await stakingContract.methods.stake(tokenIds).send({ from: accounts[0] });
                console.log('Staked successfully in ChainGPT pool:', receipt);
            } catch (error) {
                console.error('Error staking in ChainGPT pool:', error);
            }
        }
    }

    async function unstakeToken(pool) {
        const stakingContract = new web3.eth.Contract(stakingAbi, stakingContractAddress);
        let tokenIds;

        if (pool === "4token") {
            // Fetch token IDs from the 'Token Id Input Fud' input field
            tokenIds = document.querySelector('#TokenIdInputFud').value.split(',').map(id => parseInt(id.trim()));

            // Logic for unstaking in "Ignore Fud" pool
            try {
                const receipt = await stakingContract.methods.withdraw(tokenIds).send({ from: accounts[0] });
                console.log('Unstaked successfully from Ignore Fud pool:', receipt);
            } catch (error) {
                console.error('Error unstaking from Ignore Fud pool:', error);
            }
        } else if (pool === "ChainGPT") {
            // Fetch token IDs from the 'Token ID Input Chain' input field
            tokenIds = document.querySelector('#TokenIdInputChain').value.split(',').map(id => parseInt(id.trim()));

            // Logic for unstaking in "ChainGPT" pool
            try {
                const receipt = await stakingContract.methods.withdraw(tokenIds).send({ from: accounts[0] });
                console.log('Unstaked successfully from ChainGPT pool:', receipt);
            } catch (error) {
                console.error('Error unstaking from ChainGPT pool:', error);
            }
        }
    }


    async function claimRewards(pool) {
        const stakingContract = new web3.eth.Contract(stakingAbi, stakingContractAddress);
        if (pool === "4token") {
            // Logic for claiming rewards in "Ignore Fud" pool
            try {
                const receipt = await stakingContract.methods.claimRewards().send({ from: accounts[0] });
                console.log('Rewards claimed successfully from Ignore Fud pool:', receipt);
            } catch (error) {
                console.error('Error claiming rewards from Ignore Fud pool:', error);
            }
        } else if (pool === "ChainGPT") {
            // Logic for claiming rewards in "ChainGPT" pool
            try {
                const receipt = await stakingContract.methods.claimRewards().send({ from: accounts[0] });
                console.log('Rewards claimed successfully from ChainGPT pool:', receipt);
            } catch (error) {
                console.error('Error claiming rewards from ChainGPT pool:', error);
            }
        }
    }

    async function checkRewards(pool) {
        const stakingContract = new web3.eth.Contract(stakingAbi, stakingContractAddress);
        if (pool === "4token") {
            // Logic for checking rewards in "Ignore Fud" pool
            try {
                const rewards = await stakingContract.methods.userStakeRewards(accounts[0]).call();
                console.log('Rewards for Ignore Fud pool:', rewards);
            } catch (error) {
                console.error('Error checking rewards for Ignore Fud pool:', error);
            }
        } else if (pool === "ChainGPT") {
            // Logic for checking rewards in "ChainGPT" pool
            try {
                const rewards = await stakingContract.methods.userStakeRewards(accounts[0]).call();
                console.log('Rewards for ChainGPT pool:', rewards);
            } catch (error) {
                console.error('Error checking rewards for ChainGPT pool:', error);
            }
        }
    }


    // buttons or event listeners
    document.querySelector(".stake-fud").addEventListener("click", function () {
        stakeToken("4token");
    });
    document.querySelector(".unstake-fud").addEventListener("click", function () {
        unstakeToken("4token");
    });
    document.querySelector(".claim-fud").addEventListener("click", function () {
        claimRewards("4token");
    });
    document.querySelector(".check-fud").addEventListener("click", function () {
        checkRewards("4token");
    });

    document.querySelector(".stake-chain-gpt").addEventListener("click", function () {
        stakeToken("ChainGPT");
    });
    document.querySelector(".unstake-chain-gpt").addEventListener("click", function () {
        unstakeToken("ChainGPT");
    });
    document.querySelector(".claim-chain-gpt").addEventListener("click", function () {
        claimRewards("ChainGPT");
    });
    document.querySelector(".check-chain-gpt").addEventListener("click", function () {
        checkRewards("ChainGPT");
    });


</script>
